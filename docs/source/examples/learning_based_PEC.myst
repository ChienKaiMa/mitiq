---
jupytext:
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.4
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# Learning-based PEC

This notebook is a demonstration of learning a noise model used for calculating
quasiprobability representations to be used in the PEC technique. 

## 
```{code-cell} ipython3
import numpy as np
import cirq
from cirq import DensityMatrixSimulator, Circuit
from mitiq import Observable, PauliString, pec
from mitiq.interface import convert_to_mitiq, mitiq_cirq
from mitiq.pec.representations import learn_biased_noise_parameters
```

# Circuit
```{code-cell} ipython3
a, b = cirq.LineQubit.range(2)
circuit = cirq.Circuit(
    cirq.rx(0.1).on(a),
    cirq.rx(-0.72).on(b),
    cirq.rz(0.4).on(a),
    cirq.rz(0.2).on(b),
    cirq.CNOT.on(a, b),
    cirq.rx(-0.1).on(b),
    cirq.rz(-0.23).on(a),
    cirq.CNOT.on(b, a),
    cirq.rx(-0.112).on(a),
)
# Executor: Reusing CDR example simulator
# Ideal simulator
```{code-cell} ipython3
def simulator(circuit: cirq.Circuit) -> np.ndarray:
    return mitiq_cirq.compute_density_matrix(circuit, noise_level=(0.0,))
```

# Noisy executor (noisy simulator in this example)
```{code-cell} ipython3
def noisy_executor(circ: Circuit) -> np.ndarray:
    return mitiq_cirq.compute_density_matrix(circuit)
```

# Define observable
```{code-cell} ipython3
obs = Observable(PauliString("Z", support=(1,)))
```

# Learning the representations for each operation
```{code-cell} ipython3
representations = [ ]
for operation in circuit:
    representations.append(learn_biased_noise_parameters(operation, circuit, simulator, 
       noisy_executor, obs))
```

# Mitigated result
```{code-cell} ipython3
pec_value, pec_data = pec.execute_with_pec(
    circuit=circuit,
    observable=obs,
    executor=noisy_executor,
    representations=representations,
    num_samples = 1000,
    full_output=True,
    random_state = np.random.RandomState(7)
)
```
